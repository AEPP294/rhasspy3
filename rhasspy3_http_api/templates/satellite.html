{% extends "layout.html" %}

{% block body %}

<h1>Satellite</h1>

<h2>Push to Talk</h2>

<ol>
  <li>
    Pipeline:
    <select id="pipeline_name">
      <option value="default">default</option>
      {% set pipelines = config.pipelines | sort %}
      {% for pipeline in pipelines: %}
      {% if pipeline != "default": %}
      <option>{{ pipeline }}</option>
      {% endif %}
      {% endfor %}
    </select>
  </li>
  <li>
    ASR Program:
    <select id="pipeline_asr_program">
      <option value="">default</option>
      {% set programs = config.programs["asr"] | sort %}
      {% for program in programs: %}
      <option>{{ program }}</option>
      {% endfor %}
    </select>
  </li>
  <li>
    VAD Program:
    <select id="pipeline_vad_program">
      <option value="">default</option>
      {% set programs = config.programs["vad"] | sort %}
      {% for program in programs: %}
      <option>{{ program }}</option>
      {% endfor %}
    </select>
  </li>
  <li>
    Handle Program:
    <select id="pipeline_handle_program">
      <option value="">default</option>
      {% set programs = config.programs["handle"] | sort %}
      {% for program in programs: %}
      <option>{{ program }}</option>
      {% endfor %}
    </select>
  </li>
  <li>
    TTS Program:
    <select id="pipeline_tts_program">
      <option value="">default</option>
      {% set programs = config.programs["tts"] | sort %}
      {% for program in programs: %}
      <option>{{ program }}</option>
      {% endfor %}
    </select>
  </li>
  <li>
    <button id="enable_mic" onclick="enable_mic()">Enable Microphone</button>
    <button id="click_to_talk" onclick="click_to_talk()" hidden>Click to Talk</button>
  </li>
  <li>
    Status: <span id="pipeline_status">Microphone disabled</span>
  </li>
  <li>
    <audio id="tts_audio" preload="none" controls autoplay></audio>
  </li>
</ol>

<script type="text/javascript">

function enable_mic() {
    navigator.mediaDevices
        .getUserMedia({ video: false, audio: true })
        .then((stream) => {
            q("#enable_mic").hidden = true;
            q("#click_to_talk").hidden = false;
        })
        .catch((err) => {
            alert(err);
        });
}

// https://stackoverflow.com/questions/62093473/how-to-play-raw-audio-files
function buildWaveHeader(opts) {
  const numFrames =      opts.numFrames;
  const numChannels =    opts.numChannels || 2;
  const sampleRate =     opts.sampleRate || 44100;
  const bytesPerSample = opts.bytesPerSample || 2;
  const format =         opts.format

  const blockAlign = numChannels * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = numFrames * blockAlign;

  const buffer = new ArrayBuffer(44);
  const dv = new DataView(buffer);

  let p = 0;

  function writeString(s) {
    for (let i = 0; i < s.length; i++) {
      dv.setUint8(p + i, s.charCodeAt(i));
    }
    p += s.length;
  }

  function writeUint32(d) {
    dv.setUint32(p, d, true);
    p += 4;
  }

  function writeUint16(d) {
    dv.setUint16(p, d, true);
    p += 2;
  }

  writeString('RIFF');              // ChunkID
  writeUint32(dataSize + 36);       // ChunkSize
  writeString('WAVE');              // Format
  writeString('fmt ');              // Subchunk1ID
  writeUint32(16);                  // Subchunk1Size
  writeUint16(format);              // AudioFormat
  writeUint16(numChannels);         // NumChannels
  writeUint32(sampleRate);          // SampleRate
  writeUint32(byteRate);            // ByteRate
  writeUint16(blockAlign);          // BlockAlign
  writeUint16(bytesPerSample * 8);  // BitsPerSample
  writeString('data');              // Subchunk2ID
  writeUint32(dataSize);            // Subchunk2Size

  return buffer;
}

async function click_to_talk() {
    const pipelineName = q("#pipeline_name").value;

    // const asrProgram = q("#pipeline_asr_program").value;
    // const vadProgram = q("#pipeline_vad_program").value;
    // const handleProgram = q("#pipeline_handle_program").value;
    // const ttsProgram = q("#pipeline_tts_program").value;

    const status = q("#pipeline_status");
    status.innerText = "Connecting";

    const context = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    await context.audioWorklet.addModule("/js/recorder.worklet.js");

    const websocket = new WebSocket("ws://" + location.host + "/pipeline/asr-tts"
                                    + "?in_rate=" + encodeURIComponent(context.sampleRate)
                                    + "&out_rate=" + encodeURIComponent(22050));

    websocket.binaryType = "arraybuffer";
    websocket.onopen = function() {
        status.innerText = "Connected";

        const source = context.createMediaStreamSource(stream);
        const recorder = new AudioWorkletNode(context, "recorder.worklet");
        source.connect(recorder).connect(context.destination);
        recorder.port.onmessage = function(e) {
            websocket.send(e.data);
        };
    };

    let audioArrayBuffers = [];
    let numAudioBytes = 0;
    websocket.onmessage = function(e) {
        if (typeof e.data === "string") {
            status.innerText = e.data;
        } else {
            audioArrayBuffers.push(e.data);
            numAudioBytes += e.data.byteLength;
        }
    };

    websocket.onclose = function() {
        const audioBytes = new Uint8Array(numAudioBytes);

        // Copy to single buffer
        let audioBytesIndex = 0;
        for (let i = 0; i < audioArrayBuffers.length; i++) {
            const buffer = audioArrayBuffers[i];
            audioBytes.set(new Uint8Array(buffer), audioBytesIndex);
            audioBytesIndex += buffer.byteLength;
        }
        
        const wavHeader = new Uint8Array(buildWaveHeader({
            numFrames: audioBytes.byteLength / 2,
            bytesPerSample: 2,
            sampleRate: 22050,
            numChannels: 1,
            format: 1
        }))

        // create WAV file with header and downloaded PCM audio
        const wavBytes = new Uint8Array(wavHeader.length + audioBytes.byteLength)
        wavBytes.set(wavHeader, 0)
        wavBytes.set(audioBytes, wavHeader.length)
        const blob = new Blob([wavBytes], { "type": "audio/wav" });

        q("#tts_audio").src = window.URL.createObjectURL(blob);
    };

}

</script>



{% endblock %}
